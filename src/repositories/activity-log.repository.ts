import prisma from '../utils/prisma';
import logger from '../utils/logger';
import { Prisma } from '@prisma/client';

type JsonValue = Prisma.JsonValue;
type InputJsonValue = Prisma.InputJsonValue;

// Type for Prisma query arguments
type QueryArgs = {
  where?: Record<string, unknown>;
  orderBy?: Record<string, string>;
  take?: number;
  skip?: number;
};

// Type for create data
type CreateData = {
  data: {
    activity_type: string;
    actor_id?: number | null;
    target_type?: string | null;
    target_id?: number | null;
    action: string;
    details?: InputJsonValue | null;
  };
};

// Define a type for activity log database model
type ActivityLogModel = {
  id: string | number | bigint;
  activity_type: string;
  actor_id: string | number | bigint | null;
  target_type: string | null;
  target_id: string | number | bigint | null;
  action: string;
  details: JsonValue | null;
  created_at: Date | null;
};

/**
 * ActivityLog
 * @param id - The ID of the activity log
 * @param activity_type - The type of activity (e.g., 'CLOCKING_CREATED', 'TERMINAL_CONNECTED')
 * @param actor_id - The ID of the actor that performed the activity (e.g., terminal ID)
 * @param target_type - The type of target affected by the activity (e.g., 'TERMINAL', 'CLOCKING')
 * @param target_id - The ID of the target affected by the activity
 * @param action - The action performed (e.g., 'CREATE', 'UPDATE', 'DELETE', 'CONNECT')
 * @param details - Additional details about the activity (stored as JSON)
 * @param created_at - The date and time the activity was logged
 */
export interface ActivityLog {
  id: number;
  activity_type: string;
  actor_id: number | null;
  target_type: string | null;
  target_id: number | null;
  action: string;
  details: JsonValue | null;
  created_at: Date | null;
}

/**
 * Required fields for creating an activity log
 */
export interface ActivityLogCreateInput {
  activity_type: string;
  actor_id?: number | null;
  target_type?: string | null;
  target_id?: number | null;
  action: string;
  details?: InputJsonValue | null;
}

/**
 * Filter options for querying activity logs
 */
export interface ActivityLogFilter {
  actor_id?: number;
  target_type?: string;
  target_id?: number;
  activity_type?: string;
  action?: string;
  start_date?: Date;
  end_date?: Date;
  limit?: number;
  offset?: number;
}

/**
 * ActivityLog repository for interacting with the activity_logs table
 */
export class ActivityLogRepository {
  /**
   * Convert database result to ActivityLog interface
   */
  private static toActivityLog(log: ActivityLogModel): ActivityLog {
    return {
      id: Number(log.id),
      activity_type: log.activity_type,
      actor_id: log.actor_id !== null ? Number(log.actor_id) : null,
      target_type: log.target_type,
      target_id: log.target_id !== null ? Number(log.target_id) : null,
      action: log.action,
      details: log.details,
      created_at: log.created_at
    };
  }

  /**
   * Find all activity logs with optional filtering
   * @param filter - Filter options for the activity logs
   * @returns Activity logs that match the filter
   */
  static async findAll(filter?: ActivityLogFilter): Promise<ActivityLog[]> {
    try {
      const where: Record<string, unknown> = {};
      
      if (filter?.actor_id !== undefined) {
        where.actor_id = filter.actor_id;
      }
      
      if (filter?.target_type !== undefined) {
        where.target_type = filter.target_type;
      }
      
      if (filter?.target_id !== undefined) {
        where.target_id = filter.target_id;
      }
      
      if (filter?.activity_type !== undefined) {
        where.activity_type = filter.activity_type;
      }
      
      if (filter?.action !== undefined) {
        where.action = filter.action;
      }
      
      if (filter?.start_date !== undefined || filter?.end_date !== undefined) {
        where.created_at = {};
        
        if (filter?.start_date !== undefined) {
          (where.created_at as Record<string, Date>).gte = filter.start_date;
        }
        
        if (filter?.end_date !== undefined) {
          (where.created_at as Record<string, Date>).lte = filter.end_date;
        }
      }
      
      // Type assertion is necessary since activity_logs is dynamically generated by Prisma
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const dynamicPrisma = prisma as any;
      const args: QueryArgs = {
        where,
        orderBy: { created_at: 'desc' },
        take: filter?.limit || 100,
        skip: filter?.offset || 0
      };
      
      const results = await dynamicPrisma.activity_logs.findMany(args);
      
      return Array.isArray(results) 
        ? results.map((log: ActivityLogModel) => this.toActivityLog(log)) 
        : [];
    } catch (error) {
      logger.error(`Error finding activity logs: ${error instanceof Error ? error.message : String(error)}`);
      return [];
    }
  }

  /**
   * Find an activity log by ID
   * @param id - The ID of the activity log to find
   * @returns The activity log or null if not found
   */
  static async findById(id: number): Promise<ActivityLog | null> {
    try {
      // Type assertion is necessary since activity_logs is dynamically generated by Prisma
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const dynamicPrisma = prisma as any;
      
      const log = await dynamicPrisma.activity_logs.findUnique({
        where: { id }
      });
      
      if (!log) return null;
      
      return this.toActivityLog(log as ActivityLogModel);
    } catch (error) {
      logger.error(`Error finding activity log by ID: ${error instanceof Error ? error.message : String(error)}`);
      return null;
    }
  }

  /**
   * Find activity logs by actor ID
   * @param actorId - The ID of the actor to find logs for
   * @returns Activity logs for the specified actor
   */
  static async findByActorId(actorId: number, limit = 100, offset = 0): Promise<ActivityLog[]> {
    try {
      // Type assertion is necessary since activity_logs is dynamically generated by Prisma
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const dynamicPrisma = prisma as any;
      
      const results = await dynamicPrisma.activity_logs.findMany({
        where: { actor_id: actorId },
        orderBy: { created_at: 'desc' },
        take: limit,
        skip: offset
      });
      
      return Array.isArray(results) 
        ? results.map((log: ActivityLogModel) => this.toActivityLog(log)) 
        : [];
    } catch (error) {
      logger.error(`Error finding activity logs by actor ID: ${error instanceof Error ? error.message : String(error)}`);
      return [];
    }
  }

  /**
   * Find activity logs by target type and ID
   * @param targetType - The type of target to find logs for
   * @param targetId - The ID of the target to find logs for
   * @returns Activity logs for the specified target
   */
  static async findByTarget(targetType: string, targetId: number, limit = 100, offset = 0): Promise<ActivityLog[]> {
    try {
      // Type assertion is necessary since activity_logs is dynamically generated by Prisma
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const dynamicPrisma = prisma as any;
      
      const results = await dynamicPrisma.activity_logs.findMany({
        where: { 
          target_type: targetType,
          target_id: targetId
        },
        orderBy: { created_at: 'desc' },
        take: limit,
        skip: offset
      });
      
      return Array.isArray(results) 
        ? results.map((log: ActivityLogModel) => this.toActivityLog(log)) 
        : [];
    } catch (error) {
      logger.error(`Error finding activity logs by target: ${error instanceof Error ? error.message : String(error)}`);
      return [];
    }
  }

  /**
   * Create a new activity log
   * @param data - The data for the activity log to create
   * @returns The created activity log or null if an error occurs
   */
  static async create(data: ActivityLogCreateInput): Promise<ActivityLog | null> {
    try {
      // Type assertion is necessary since activity_logs is dynamically generated by Prisma
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const dynamicPrisma = prisma as any;
      
      const createData: CreateData = {
        data: {
          activity_type: data.activity_type,
          actor_id: data.actor_id,
          target_type: data.target_type,
          target_id: data.target_id,
          action: data.action,
          details: data.details
        }
      };
      
      const log = await dynamicPrisma.activity_logs.create(createData);
      
      return this.toActivityLog(log as ActivityLogModel);
    } catch (error) {
      logger.error(`Error creating activity log: ${error instanceof Error ? error.message : String(error)}`);
      return null;
    }
  }

  /**
   * Count all activity logs with optional filtering
   * @param filter - Filter options for the activity logs
   * @returns Count of activity logs that match the filter
   */
  static async count(filter?: ActivityLogFilter): Promise<number> {
    try {
      const where: Record<string, unknown> = {};
      
      if (filter?.actor_id !== undefined) {
        where.actor_id = filter.actor_id;
      }
      
      if (filter?.target_type !== undefined) {
        where.target_type = filter.target_type;
      }
      
      if (filter?.target_id !== undefined) {
        where.target_id = filter.target_id;
      }
      
      if (filter?.activity_type !== undefined) {
        where.activity_type = filter.activity_type;
      }
      
      if (filter?.action !== undefined) {
        where.action = filter.action;
      }
      
      if (filter?.start_date !== undefined || filter?.end_date !== undefined) {
        where.created_at = {};
        
        if (filter?.start_date !== undefined) {
          (where.created_at as Record<string, Date>).gte = filter.start_date;
        }
        
        if (filter?.end_date !== undefined) {
          (where.created_at as Record<string, Date>).lte = filter.end_date;
        }
      }
      
      // Type assertion is necessary since activity_logs is dynamically generated by Prisma
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const dynamicPrisma = prisma as any;
      return await dynamicPrisma.activity_logs.count({ where });
    } catch (error) {
      logger.error(`Error counting activity logs: ${error instanceof Error ? error.message : String(error)}`);
      return 0;
    }
  }
} 